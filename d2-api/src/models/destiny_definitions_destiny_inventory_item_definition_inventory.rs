/*
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.16.0
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 */

/// DestinyDefinitionsDestinyInventoryItemDefinitionInventory : If this item can exist in an inventory, this block will be non-null. In practice, every item that currently exists has one of these blocks. But note that it is not necessarily guaranteed.



#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct DestinyDefinitionsDestinyInventoryItemDefinitionInventory {
    /// If this string is populated, you can't have more than one stack with this label in a given inventory. Note that this is different from the equipping block's unique label, which is used for equipping uniqueness.
    #[serde(rename = "stackUniqueLabel", skip_serializing_if = "Option::is_none")]
    pub stack_unique_label: Option<String>,
    /// The maximum quantity of this item that can exist in a stack.
    #[serde(rename = "maxStackSize", skip_serializing_if = "Option::is_none")]
    pub max_stack_size: Option<i32>,
    /// The hash identifier for the DestinyInventoryBucketDefinition to which this item belongs. I should have named this \"bucketHash\", but too many things refer to it now. Sigh.
    #[serde(rename = "bucketTypeHash", skip_serializing_if = "Option::is_none")]
    pub bucket_type_hash: Option<i32>,
    /// If the item is picked up by the lost loot queue, this is the hash identifier for the DestinyInventoryBucketDefinition into which it will be placed. Again, I should have named this recoveryBucketHash instead.
    #[serde(rename = "recoveryBucketTypeHash", skip_serializing_if = "Option::is_none")]
    pub recovery_bucket_type_hash: Option<i32>,
    /// The hash identifier for the Tier Type of the item, use to look up its DestinyItemTierTypeDefinition if you need to show localized data for the item's tier.
    #[serde(rename = "tierTypeHash", skip_serializing_if = "Option::is_none")]
    pub tier_type_hash: Option<i32>,
    /// If TRUE, this item is instanced. Otherwise, it is a generic item that merely has a quantity in a stack (like Glimmer).
    #[serde(rename = "isInstanceItem", skip_serializing_if = "Option::is_none")]
    pub is_instance_item: Option<bool>,
    /// The localized name of the tier type, which is a useful shortcut so you don't have to look up the definition every time. However, it's mostly a holdover from days before we had a DestinyItemTierTypeDefinition to refer to.
    #[serde(rename = "tierTypeName", skip_serializing_if = "Option::is_none")]
    pub tier_type_name: Option<String>,
    /// The enumeration matching the tier type of the item to known values, again for convenience sake.
    #[serde(rename = "tierType", skip_serializing_if = "Option::is_none")]
    pub tier_type: Option<i32>,
    /// The tooltip message to show, if any, when the item expires.
    #[serde(rename = "expirationTooltip", skip_serializing_if = "Option::is_none")]
    pub expiration_tooltip: Option<String>,
    /// If the item expires while playing in an activity, we show a different message.
    #[serde(rename = "expiredInActivityMessage", skip_serializing_if = "Option::is_none")]
    pub expired_in_activity_message: Option<String>,
    /// If the item expires in orbit, we show a... more different message. (\"Consummate V's, consummate!\")
    #[serde(rename = "expiredInOrbitMessage", skip_serializing_if = "Option::is_none")]
    pub expired_in_orbit_message: Option<String>,
    #[serde(rename = "suppressExpirationWhenObjectivesComplete", skip_serializing_if = "Option::is_none")]
    pub suppress_expiration_when_objectives_complete: Option<bool>,
    /// A reference to the associated crafting 'recipe' item definition, if this item can be crafted.
    #[serde(rename = "recipeItemHash", skip_serializing_if = "Option::is_none")]
    pub recipe_item_hash: Option<i32>,
}

impl DestinyDefinitionsDestinyInventoryItemDefinitionInventory {
    /// If this item can exist in an inventory, this block will be non-null. In practice, every item that currently exists has one of these blocks. But note that it is not necessarily guaranteed.
    pub fn new() -> DestinyDefinitionsDestinyInventoryItemDefinitionInventory {
        DestinyDefinitionsDestinyInventoryItemDefinitionInventory {
            stack_unique_label: None,
            max_stack_size: None,
            bucket_type_hash: None,
            recovery_bucket_type_hash: None,
            tier_type_hash: None,
            is_instance_item: None,
            tier_type_name: None,
            tier_type: None,
            expiration_tooltip: None,
            expired_in_activity_message: None,
            expired_in_orbit_message: None,
            suppress_expiration_when_objectives_complete: None,
            recipe_item_hash: None,
        }
    }
}


