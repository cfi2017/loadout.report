/*
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.16.0
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`group_v2_period_abdicate_foundership`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodAbdicateFoundershipError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_add_optional_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodAddOptionalConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_approve_all_pending`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodApproveAllPendingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_approve_pending`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodApprovePendingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_approve_pending_for_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodApprovePendingForListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_ban_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodBanMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_deny_all_pending`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodDenyAllPendingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_deny_pending_for_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodDenyPendingForListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_edit_clan_banner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodEditClanBannerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_edit_founder_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodEditFounderOptionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_edit_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodEditGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_edit_group_membership`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodEditGroupMembershipError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_edit_optional_conversation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodEditOptionalConversationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_admins_and_founder_of_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetAdminsAndFounderOfGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_available_avatars`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetAvailableAvatarsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_available_themes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetAvailableThemesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_banned_members_of_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetBannedMembersOfGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_group_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetGroupByNameError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_group_by_name_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetGroupByNameV2Error {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_group_optional_conversations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetGroupOptionalConversationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_groups_for_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetGroupsForMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_invited_individuals`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetInvitedIndividualsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_members_of_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetMembersOfGroupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_pending_memberships`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetPendingMembershipsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_potential_groups_for_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetPotentialGroupsForMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_recommended_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetRecommendedGroupsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_get_user_clan_invite_setting`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGetUserClanInviteSettingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_group_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodGroupSearchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_individual_group_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodIndividualGroupInviteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_individual_group_invite_cancel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodIndividualGroupInviteCancelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_kick_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodKickMemberError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_recover_group_for_founder`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodRecoverGroupForFounderError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`group_v2_period_unban_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GroupV2PeriodUnbanMemberError {
    UnknownValue(serde_json::Value),
}


/// An administrative method to allow the founder of a group or clan to give up their position to another admin permanently.
pub async fn group_v2_period_abdicate_foundership(configuration: &configuration::Configuration, founder_id_new: i64, group_id: i64, membership_type: i32) -> Result<crate::models::GroupV2GetUserClanInviteSetting200Response, Error<GroupV2PeriodAbdicateFoundershipError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Admin/AbdicateFoundership/{membershipType}/{founderIdNew}/", local_var_configuration.base_path, founderIdNew=founder_id_new, groupId=group_id, membershipType=membership_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodAbdicateFoundershipError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Add a new optional conversation/chat channel. Requires admin permissions to the group.
pub async fn group_v2_period_add_optional_conversation(configuration: &configuration::Configuration, group_id: i64) -> Result<crate::models::ForumGetTopicForContent200Response, Error<GroupV2PeriodAddOptionalConversationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/OptionalConversations/Add/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodAddOptionalConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Approve all of the pending users for the given group.
pub async fn group_v2_period_approve_all_pending(configuration: &configuration::Configuration, group_id: i64) -> Result<crate::models::GroupV2ApproveAllPending200Response, Error<GroupV2PeriodApproveAllPendingError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/ApproveAll/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodApproveAllPendingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Approve the given membershipId to join the group/clan as long as they have applied.
pub async fn group_v2_period_approve_pending(configuration: &configuration::Configuration, group_id: i64, membership_id: i64, membership_type: i32) -> Result<crate::models::GroupV2GetUserClanInviteSetting200Response, Error<GroupV2PeriodApprovePendingError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/Approve/{membershipType}/{membershipId}/", local_var_configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodApprovePendingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Approve all of the pending users for the given group.
pub async fn group_v2_period_approve_pending_for_list(configuration: &configuration::Configuration, group_id: i64) -> Result<crate::models::GroupV2ApproveAllPending200Response, Error<GroupV2PeriodApprovePendingForListError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/ApproveList/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodApprovePendingForListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Bans the requested member from the requested group for the specified period of time.
pub async fn group_v2_period_ban_member(configuration: &configuration::Configuration, group_id: i64, membership_id: i64, membership_type: i32) -> Result<crate::models::GroupV2EditGroup200Response, Error<GroupV2PeriodBanMemberError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Ban/", local_var_configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodBanMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deny all of the pending users for the given group.
pub async fn group_v2_period_deny_all_pending(configuration: &configuration::Configuration, group_id: i64) -> Result<crate::models::GroupV2ApproveAllPending200Response, Error<GroupV2PeriodDenyAllPendingError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/DenyAll/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodDenyAllPendingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deny all of the pending users for the given group that match the passed-in .
pub async fn group_v2_period_deny_pending_for_list(configuration: &configuration::Configuration, group_id: i64) -> Result<crate::models::GroupV2ApproveAllPending200Response, Error<GroupV2PeriodDenyPendingForListError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/DenyList/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodDenyPendingForListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Edit an existing group's clan banner. You must have suitable permissions in the group to perform this operation. All fields are required.
pub async fn group_v2_period_edit_clan_banner(configuration: &configuration::Configuration, group_id: i64) -> Result<crate::models::GroupV2EditGroup200Response, Error<GroupV2PeriodEditClanBannerError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/EditClanBanner/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodEditClanBannerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Edit group options only available to a founder. You must have suitable permissions in the group to perform this operation.
pub async fn group_v2_period_edit_founder_options(configuration: &configuration::Configuration, group_id: i64) -> Result<crate::models::GroupV2EditGroup200Response, Error<GroupV2PeriodEditFounderOptionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/EditFounderOptions/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodEditFounderOptionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Edit an existing group. You must have suitable permissions in the group to perform this operation. This latest revision will only edit the fields you pass in - pass null for properties you want to leave unaltered.
pub async fn group_v2_period_edit_group(configuration: &configuration::Configuration, group_id: i64) -> Result<crate::models::GroupV2EditGroup200Response, Error<GroupV2PeriodEditGroupError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Edit/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodEditGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Edit the membership type of a given member. You must have suitable permissions in the group to perform this operation.
pub async fn group_v2_period_edit_group_membership(configuration: &configuration::Configuration, group_id: i64, membership_id: i64, membership_type: i32, member_type: i32) -> Result<crate::models::GroupV2EditGroup200Response, Error<GroupV2PeriodEditGroupMembershipError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/SetMembershipType/{memberType}/", local_var_configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type, memberType=member_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodEditGroupMembershipError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Edit the settings of an optional conversation/chat channel. Requires admin permissions to the group.
pub async fn group_v2_period_edit_optional_conversation(configuration: &configuration::Configuration, conversation_id: i64, group_id: i64) -> Result<crate::models::ForumGetTopicForContent200Response, Error<GroupV2PeriodEditOptionalConversationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/OptionalConversations/Edit/{conversationId}/", local_var_configuration.base_path, conversationId=conversation_id, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodEditOptionalConversationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the list of members in a given group who are of admin level or higher.
pub async fn group_v2_period_get_admins_and_founder_of_group(configuration: &configuration::Configuration, currentpage: i32, group_id: i64) -> Result<crate::models::GroupV2GetMembersOfGroup200Response, Error<GroupV2PeriodGetAdminsAndFounderOfGroupError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/AdminsAndFounder/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetAdminsAndFounderOfGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of all available group avatars for the signed-in user.
pub async fn group_v2_period_get_available_avatars(configuration: &configuration::Configuration, ) -> Result<crate::models::UserGetSanitizedPlatformDisplayNames200Response, Error<GroupV2PeriodGetAvailableAvatarsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/GetAvailableAvatars/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetAvailableAvatarsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of all available group themes.
pub async fn group_v2_period_get_available_themes(configuration: &configuration::Configuration, ) -> Result<crate::models::GroupV2GetAvailableThemes200Response, Error<GroupV2PeriodGetAvailableThemesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/GetAvailableThemes/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetAvailableThemesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the list of banned members in a given group. Only accessible to group Admins and above. Not applicable to all groups. Check group features.
pub async fn group_v2_period_get_banned_members_of_group(configuration: &configuration::Configuration, currentpage: i32, group_id: i64) -> Result<crate::models::GroupV2GetBannedMembersOfGroup200Response, Error<GroupV2PeriodGetBannedMembersOfGroupError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Banned/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetBannedMembersOfGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get information about a specific group of the given ID.
pub async fn group_v2_period_get_group(configuration: &configuration::Configuration, group_id: i64) -> Result<crate::models::GroupV2GetGroup200Response, Error<GroupV2PeriodGetGroupError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get information about a specific group with the given name and type.
pub async fn group_v2_period_get_group_by_name(configuration: &configuration::Configuration, group_name: &str, group_type: i32) -> Result<crate::models::GroupV2GetGroup200Response, Error<GroupV2PeriodGetGroupByNameError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/Name/{groupName}/{groupType}/", local_var_configuration.base_path, groupName=crate::apis::urlencode(group_name), groupType=group_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetGroupByNameError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get information about a specific group with the given name and type. The POST version.
pub async fn group_v2_period_get_group_by_name_v2(configuration: &configuration::Configuration, ) -> Result<crate::models::GroupV2GetGroup200Response, Error<GroupV2PeriodGetGroupByNameV2Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/NameV2/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetGroupByNameV2Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a list of available optional conversation channels and their settings.
pub async fn group_v2_period_get_group_optional_conversations(configuration: &configuration::Configuration, group_id: i64) -> Result<crate::models::GroupV2GetGroupOptionalConversations200Response, Error<GroupV2PeriodGetGroupOptionalConversationsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/OptionalConversations/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetGroupOptionalConversationsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get information about the groups that a given member has joined.
pub async fn group_v2_period_get_groups_for_member(configuration: &configuration::Configuration, filter: i32, group_type: i32, membership_id: i64, membership_type: i32) -> Result<crate::models::GroupV2GetGroupsForMember200Response, Error<GroupV2PeriodGetGroupsForMemberError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/User/{membershipType}/{membershipId}/{filter}/{groupType}/", local_var_configuration.base_path, filter=filter, groupType=group_type, membershipId=membership_id, membershipType=membership_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetGroupsForMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the list of users who have been invited into the group.
pub async fn group_v2_period_get_invited_individuals(configuration: &configuration::Configuration, currentpage: i32, group_id: i64) -> Result<crate::models::GroupV2GetPendingMemberships200Response, Error<GroupV2PeriodGetInvitedIndividualsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/InvitedIndividuals/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetInvitedIndividualsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the list of members in a given group.
pub async fn group_v2_period_get_members_of_group(configuration: &configuration::Configuration, currentpage: i32, group_id: i64, member_type: Option<i32>, name_search: Option<&str>) -> Result<crate::models::GroupV2GetMembersOfGroup200Response, Error<GroupV2PeriodGetMembersOfGroupError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = member_type {
        local_var_req_builder = local_var_req_builder.query(&[("memberType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name_search {
        local_var_req_builder = local_var_req_builder.query(&[("nameSearch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetMembersOfGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the list of users who are awaiting a decision on their application to join a given group. Modified to include application info.
pub async fn group_v2_period_get_pending_memberships(configuration: &configuration::Configuration, currentpage: i32, group_id: i64) -> Result<crate::models::GroupV2GetPendingMemberships200Response, Error<GroupV2PeriodGetPendingMembershipsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/Pending/", local_var_configuration.base_path, groupId=group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetPendingMembershipsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get information about the groups that a given member has applied to or been invited to.
pub async fn group_v2_period_get_potential_groups_for_member(configuration: &configuration::Configuration, filter: i32, group_type: i32, membership_id: i64, membership_type: i32) -> Result<crate::models::GroupV2GetPotentialGroupsForMember200Response, Error<GroupV2PeriodGetPotentialGroupsForMemberError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/User/Potential/{membershipType}/{membershipId}/{filter}/{groupType}/", local_var_configuration.base_path, filter=filter, groupType=group_type, membershipId=membership_id, membershipType=membership_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetPotentialGroupsForMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets groups recommended for you based on the groups to whom those you follow belong.
pub async fn group_v2_period_get_recommended_groups(configuration: &configuration::Configuration, create_date_range: i32, group_type: i32) -> Result<crate::models::GroupV2GetRecommendedGroups200Response, Error<GroupV2PeriodGetRecommendedGroupsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/Recommended/{groupType}/{createDateRange}/", local_var_configuration.base_path, createDateRange=create_date_range, groupType=group_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetRecommendedGroupsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets the state of the user's clan invite preferences for a particular membership type - true if they wish to be invited to clans, false otherwise.
pub async fn group_v2_period_get_user_clan_invite_setting(configuration: &configuration::Configuration, m_type: i32) -> Result<crate::models::GroupV2GetUserClanInviteSetting200Response, Error<GroupV2PeriodGetUserClanInviteSettingError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/GetUserClanInviteSetting/{mType}/", local_var_configuration.base_path, mType=m_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGetUserClanInviteSettingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Search for Groups.
pub async fn group_v2_period_group_search(configuration: &configuration::Configuration, ) -> Result<crate::models::GroupV2GroupSearch200Response, Error<GroupV2PeriodGroupSearchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/Search/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodGroupSearchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Invite a user to join this group.
pub async fn group_v2_period_individual_group_invite(configuration: &configuration::Configuration, group_id: i64, membership_id: i64, membership_type: i32) -> Result<crate::models::GroupV2IndividualGroupInvite200Response, Error<GroupV2PeriodIndividualGroupInviteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/IndividualInvite/{membershipType}/{membershipId}/", local_var_configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodIndividualGroupInviteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Cancels a pending invitation to join a group.
pub async fn group_v2_period_individual_group_invite_cancel(configuration: &configuration::Configuration, group_id: i64, membership_id: i64, membership_type: i32) -> Result<crate::models::GroupV2IndividualGroupInvite200Response, Error<GroupV2PeriodIndividualGroupInviteCancelError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/IndividualInviteCancel/{membershipType}/{membershipId}/", local_var_configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodIndividualGroupInviteCancelError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Kick a member from the given group, forcing them to reapply if they wish to re-join the group. You must have suitable permissions in the group to perform this operation.
pub async fn group_v2_period_kick_member(configuration: &configuration::Configuration, group_id: i64, membership_id: i64, membership_type: i32) -> Result<crate::models::GroupV2KickMember200Response, Error<GroupV2PeriodKickMemberError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Kick/", local_var_configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodKickMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Allows a founder to manually recover a group they can see in game but not on bungie.net
pub async fn group_v2_period_recover_group_for_founder(configuration: &configuration::Configuration, group_type: i32, membership_id: i64, membership_type: i32) -> Result<crate::models::GroupV2RecoverGroupForFounder200Response, Error<GroupV2PeriodRecoverGroupForFounderError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/Recover/{membershipType}/{membershipId}/{groupType}/", local_var_configuration.base_path, groupType=group_type, membershipId=membership_id, membershipType=membership_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodRecoverGroupForFounderError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Unbans the requested member, allowing them to re-apply for membership.
pub async fn group_v2_period_unban_member(configuration: &configuration::Configuration, group_id: i64, membership_id: i64, membership_type: i32) -> Result<crate::models::GroupV2EditGroup200Response, Error<GroupV2PeriodUnbanMemberError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Unban/", local_var_configuration.base_path, groupId=group_id, membershipId=membership_id, membershipType=membership_type);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GroupV2PeriodUnbanMemberError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

